(ns grotesqui.fakeql)

;;;;;;;;;;
; current-pipe
; Should always be a reference to the pipe currently displayed in the UI.
(def current-pipe nil)

(defn init-current-pipe [] (def current-pipe (ref '())))

(defmulti node :type)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pipe manipulation functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn replace-node
  "Inserts the node into the given pipe-ref."
  ([pipe new-node replace-id]
    (let 
      [category (get (second new-node) :category)
       splitlist  (split-with (fn [node] (not (= replace-id (get (second node) :id)))) pipe)
       prelist (first splitlist)
       postlist (rest (second splitlist))]
			 (cond
					(= category :input) (concat [new-node (node {:type :dropzone})] postlist)
					:else (println "ERRORRRRRRRRRRRRRRRRRRRRRRRRRR")))))

(defn insert-node
	"Inserts the node into the given pipe-ref."
	([piperef node] (dosync (alter piperef concat [node])))
	([piperef node replace-id] 
			(do
				(dosync (alter piperef replace-node node replace-id)))))



  ;"Creates a dropzone node with the text 'Drop Zone' and an autogenerated
   ;id: :dropzoneXXX to be used for reference in the UI."
(defmethod node :dropzone
  [props]
  (list "dropzone" {
    :type :dropzone
    :id (keyword (gensym "dropzone"))
    :grotesqui { :text "Drop Zone"}}))

(defmethod node :mysql-in [props] (list "mysql-in" { :type :mysql-in, :category :input, :id (keyword (gensym "mysql-in"))}))


